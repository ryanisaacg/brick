grammar:
- there's an ambiguity between dereference / multiplication in if { body } * a += 1;

error reporting:
- typecheck errors
- error presentation
- ability to continue in face of errors

linear IR:
- (maybe) AST rewrite the HIR to remove all control flow from expressions (possibly introducing "registers" if needed)
- (maybe) AST rewrite the HIR to disambiguate between variable references and function references

- rework the hashmaps into an actual environment data structure that allows for generational indexing?

compilation resume and reload:
- differentiate modules and compilation units, or give up on first class modules
- make IDs relative to compilation units
- allow a compilation pass to have some existing compilation units to start off (for partial compilation)
- REPL
    - read
    - evaluate
    - print
    - loop

tooling:
- LSP
    - go-to-definition
        - variable
        - type
        - field access
    - find references
    - hover
    - rename (probably going to be very hard)
    - list of compilation errors
    - syntax highlighting
- pretty-printer

coroutines / generators / async:
- stackless coroutines
    - alloc the generator to match its proper size
- allow values to be returned from yields
    - extract yield to temporaries if necessary
    - add a new HIR instruction to retrieve passed-down generator values
    - type yield returns correctly
    - pass down values when resuming from a generator
- support arguments to coroutines
    - either ban references from coroutine args or note that they're borrowed as long as the generator lives
    - copy arguments into the generator's initial state
- generators on associated functions
- non-infinite generators (e.g. generators should return Next(value) | Exhausted)
- error guardrails:
    - require coroutines to return generators
    - error when `yield`ing outside of a coroutine
    - prevent calling coroutine through immutable references

static data:
- add some syntax for declaring global state
- handle global state in the HIR
- handle global state in the LIR
- handle global state in the interpreter

type parameters:
- non-reified / non-monomorphizing:
    - generic type syntax
    - types can be parameterized
    - nested type parameters are correctly resolved
- monomorphizing
- generic types can be constrained by interfaces

collections:
- tuples
- arrays:
    - allow empty arrays to typecheck (requires generic type syntax)
- dicts:
    - use a hash table
    - take references as keys, not the direct key type
    - allow empty dicts to type check (requires generic type syntax)
    - should set syntax auto-insert if necessary?
- rc's:
    - basic RCs
    - can take RC'ed references to collections? maybe even RC'ed subreferences to user-defined collections?
- cells
- slices
- boxes (maybe not - maybe just RC?)
- automatically convert types when assigning collections?

borrow checker and lifetimes:
- mutable references aren't moved when they're passed to functions
- check borrows for function calls
- handle assignments - both in terms of drop detection and borrow detection
- allow disjoint borrows of struct fields
- correctly mark references through collection indices
- mark custom types as copy
- copy vs clone vs affine vs linear?
- drop (hard-coded)
- drop (custom)

metaprogramming:
- proc macros? comptime? compile-time reflection (what is that even)? no metaprogramming?
- use whatever mechanism above for ser/des

allocator:
- support dealloc

syntax:
- remove ; and , requirements?
- keyword arguments
- maybe separate syntax for i64 / f64 literals

import support:
- allow imports to have nested paths (sugar for recursively expanding?)
- allow imports to include a list of things, with an optional catch-all

modules:
- modules can be indexed in a type expression context
- modules can be indexed in a struct / variant literal context
- modules can be declared explicitly
- do files have to import each other?
- how are modules declared?

returns:
- ensure returns get expected type checked against their function in HIR

static function vs method:
    - struct associated functions support "self"
        - self can be declared as a typeless parameter syntactically
        - allow calls to associated functions through references (checking correct reference type)
        - self typechecks correctly
        - IR transforms code properly to pass self into the function
    - union associated functions support "self"
    - static associated functions:
        - structs
        - unions
        - interfaces?

interfaces:
- self parameters for interfaces can only be passed by reference (otherwise linear IR doesn't work)
    - when making the method -> function conversion, automatically take a reference if it's required
    - mandate by-reference parameters for interfaces
- unions:
    - unions can be converted to interfaces
    - unions have associated functions
- modules can be converted to interfaces:
    - produce and consume a nullpointer for the vtable call? (might mean we need to generate shim functions)
- interfaces can be converted between each other:
    - in typechecking
    - in the IR
    - in the interpreter
- interface conversion:
    - checks return statements
    - checks implicit returns due to the end of blocks
    - check assignments
- interfaces are supported in the interpreter:
    - mutable interfaces (significant borrowck implications)

interface adapters:
- allow an interface to define an impl for itself on foreign types, limited version of Rust's traits

strings:
- string manipulation
- interpolation literals
- multiline literals

semantic analysis:
- handle return, break statements in CFG parsing

anonymous types:
- anonymous struct
- anonymous union
- anonymous module
- anonymous interface

unions:
- they work:
    - union variants can be assigned to
- union literal syntax that makes sense
- unions can extend unions (refer to fields with nested access?)
- unions can have empty variants
- match statement (destructure unions, return value if exhaustive)
- are unions the right choice?? not 100% sure
- rename to enum? variant?

boolean operators:
- equality / inequality:
    - applicable to nullable values

null:
- ?. operator on union lvalues
- ! operator, which throws if the value is an error (requires errors)
- basic null flow analysis - maybe a special operation to de-null stuff

errors:
- functions can define `throws`
- throw operator creates and returns an error
- try operator returns an error if one exists
- functions may optionally define a union that they throw, and all `throw`s and `try`s in the function must conform to that union
- allow discriminating on errors with a try/catch type construct or something similar for non-throws functions

misc:
- automatically create temporaries when trying to get lvalues of function calls

backends:
- add wasm backend?
    - ensure it complies with the tooling conventions around C ABIs, so that we can call into a Rust-based runtime (https://github.com/WebAssembly/tool-conventions)
- add cranelift backend?
    - one option is to directly emit cranelift via its apis
    - another option is to generate WASM and then run Cranelift on the wasm

extern:
- opaque extern pointers
- extern functions are unsafe
- externs can only do C FFI stuff, for ease of wasm backend

unsafe:
- functions can be declared unsafe
- you can have unsafe blocks (or statements?)
- you can only call unsafe functions from within unsafe blocks

units of measure:
- design some system to separate units of measure into various domains (e.g. a "screen pixel" different from a "logical pixel")

language rules:
- don't allow recursive types without indirection

