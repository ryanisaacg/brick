linear IR:
- separate PrimitiveType abstraction and Value abstraction for linear IR
- (maybe) AST rewrite the HIR to remove all control flow from expressions (possibly introducing "registers" if needed)
- (maybe) AST rewrite the HIR to disambiguate between variable references and function references

collections:
- arrays in linear IR:
    - heapalloc
    - array support
- index operator
- array literals typechecking
- dicts:
    - dict type syntax
    - typechecking
    - interpreter
- slices
- boxes
- rc's
- cells

allocator:
- support alloc
- support dealloc

interpreter:
- union support

syntax:
- remove ; and , requirements?
- keyword arguments

import support:
- allow imports to have nested paths (sugar for recursively expanding?)
- allow imports to include a list of things, with an optional catch-all

modules:
- modules can be indexed in a type expression context
- modules can be indexed in a struct / variant literal context
- modules can be declared explicitly

returns:
- typecheck returns
- allow void returns

references:
- allow calls to associated functions through references (checking correct reference type)

interfaces:
- remove fields from interfaces? vtables just make more sense...
- self parameters for interfaces can only be passed by reference (otherwise linear IR doesn't work)
    - when making the method -> function conversion, automatically take a reference if it's required
    - mandate by-reference parameters for interfaces
- structs:
    - struct associated functions support "self"
        - self can be declared as a typeless parameter syntactically
        - self typechecks correctly
        - IR transforms code properly to pass self into the function
- unions:
    - unions can be converted to interfaces
    - union associated functions support "self"
    - union associated functions work
    - unions have associated functions
- modules can be converted to interfaces:
    - produce and consume a nullpointer for the vtable call? (might mean we need to generate shim functions)
- interfaces can be converted between each other:
    - in typechecking
    - in the IR
    - in the interpreter
- interface conversion:
    - checks return statements
    - checks implicit returns due to the end of blocks
- interfaces are supported in the interpreter:
    - mutable interfaces (significant borrowck implications)

interface adapters:
- allow an interface to define an impl for itself on foreign types, limited version of Rust's traits

static associated functions:
- structs
- unions
- interfaces?

arithmetic:
- automatically promote integers to equivalent floats

strings:
- escape sequences
- string manipulation
- interpolation literals
- multiline literals

semantic analysis:
- handle return, break statements in CFG parsing

anonymous types:
- anonymous struct
- anonymous union
- anonymous module
- anonymous interface

unions:
- are unions the right choice?? not 100% sure
- rename to enum? variant?
- union lvalues are special - can only be assigned to
- unions can extend unions (refer to fields with nested access?)
- unions can have empty variants
- match statement (destructure unions, return value if exhaustive)

null:
- basic null flow analysis - maybe a special operation to de-null stuff
- ?. operator
- ?? operator
- ! operator, which throws if the value is an error

errors:
- functions can define `throws`
- throw operator creates and returns an error
- try operator returns an error if one exists
- functions may optionally define a union that they throw, and all `throw`s and `try`s in the function must conform to that union
- allow discriminating on errors with a try/catch type construct or something similar for non-throws functions

borrow checker

coroutines:
- decide on some coroutine facility
- coroutines hold parameter borrows for their lifetime

generic programming:
- functions can take type parameters and typecheck properly
- types can be parameterized
- structs and unions can have associated functions
- there are interfaces which can require specific associated functions
- structs and unions can be passed in place of an interface
- interfaces can constrain generic parameters

extern:
- extern functions are unsafe
- externs can only do C FFI stuff, for ease of wasm backend

unsafe:
- functions can be declared unsafe
- you can have unsafe blocks (or statements?)
- you can only call unsafe functions from within unsafe blocks

units of measure:
- design some system to separate units of measure into various domains (e.g. a "screen pixel" different from a "logical pixel")

