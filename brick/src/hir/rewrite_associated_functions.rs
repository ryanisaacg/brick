use std::collections::HashMap;

use crate::{
    id::TypeID,
    runtime::{array_runtime_functions, dictionary_runtime_functions},
    typecheck::{
        fully_dereference, CollectionType, ExpressionType, InterfaceType, PointerKind,
        PrimitiveType, StaticDeclaration, StructType,
    },
};

use super::{HirNode, HirNodeValue};

pub fn rewrite(declarations: &HashMap<TypeID, &StaticDeclaration>, root: &mut HirNode) {
    // We only care about function calls that are an access on the left hand side
    let HirNodeValue::Call(call_lhs, args) = &mut root.value else {
        return;
    };
    let HirNodeValue::Access(lhs, func_name) = &mut call_lhs.value else {
        return;
    };
    match fully_dereference(&lhs.ty) {
        ExpressionType::InstanceOf(ty_id) | ExpressionType::ReferenceTo(ty_id) => {
            match declarations.get(ty_id) {
                Some(StaticDeclaration::Struct(StructType {
                    associated_functions,
                    ..
                })) => {
                    if let Some(func) = associated_functions.get(func_name) {
                        // Replace the existing left hand side with a reference to the called function
                        let mut temporary = HirNode::autogenerated(
                            HirNodeValue::VariableReference(func.unwrap_fn_id().into()),
                            func.ref_to(),
                        );
                        std::mem::swap(&mut temporary, call_lhs);
                        // Insert the struct as a parameter to the newly called function
                        let call_lhs = temporary;
                        let HirNodeValue::Access(lhs, _) = call_lhs.value else {
                            unreachable!();
                        };
                        args.insert(0, *lhs);
                    }
                }
                Some(StaticDeclaration::Interface(InterfaceType {
                    associated_functions,
                    ..
                })) => {
                    if let Some(func) = associated_functions.get(func_name) {
                        // TODO: restore this?
                        // Insert the interface as a parameter to itself
                        args.insert(
                            0,
                            HirNode::autogenerated(
                                HirNodeValue::InterfaceAddress(lhs.clone()),
                                ExpressionType::Primitive(PrimitiveType::PointerSize),
                            ),
                        );

                        let mut temp = HirNode::dummy();
                        std::mem::swap(&mut temp, root);
                        let HirNode {
                            id,
                            value: HirNodeValue::Call(lhs, args),
                            ty,
                            provenance: _,
                        } = temp
                        else {
                            unreachable!()
                        };
                        let HirNodeValue::Access(lhs, _func_name) = lhs.value else {
                            unreachable!()
                        };
                        temp = HirNode::generated_with_id(
                            id,
                            HirNodeValue::VtableCall(lhs, func.unwrap_fn_id(), args),
                            ty,
                        );
                        std::mem::swap(&mut temp, root);
                    }
                }
                _ => {}
            }
        }
        ty @ ExpressionType::Collection(col_ty) => {
            let ty = ty.clone();

            let runtime_fns = match col_ty {
                CollectionType::Array(_) => array_runtime_functions(),
                CollectionType::Dict(_, _) => dictionary_runtime_functions(),
                CollectionType::String => todo!(),
            };

            let runtime_fn = runtime_fns.get(func_name).unwrap();

            let mut temp_lhs = HirNode::dummy();
            std::mem::swap(lhs as &mut HirNode, &mut temp_lhs);

            temp_lhs = HirNode::autogenerated(
                if runtime_fn.ptr_ty == PointerKind::Shared {
                    HirNodeValue::TakeShared(Box::new(temp_lhs))
                } else {
                    HirNodeValue::TakeUnique(Box::new(temp_lhs))
                },
                ExpressionType::Pointer(PointerKind::Shared, Box::new(ty)),
            );

            let mut runtime_args = Vec::new();
            std::mem::swap(args, &mut runtime_args);
            runtime_args.insert(0, temp_lhs);

            let StaticDeclaration::Func(fn_ty) = &runtime_fn.decl else {
                unreachable!()
            };
            std::mem::swap(
                root,
                &mut HirNode::generated_with_id(
                    root.id,
                    HirNodeValue::RuntimeCall(runtime_fn.func, runtime_args),
                    fn_ty.returns.clone(),
                ),
            );
        }
        ExpressionType::Generator { .. } => {}
        ty => unreachable!(
            "illegal lhs of access in function call: {:?} in {:?}",
            ty, lhs
        ),
    }
}
