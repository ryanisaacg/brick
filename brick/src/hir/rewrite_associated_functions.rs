use crate::{
    typecheck::{
        fully_dereference, CollectionType, ExpressionType, InterfaceType, PointerKind,
        PrimitiveType, StructType, TypeDeclaration,
    },
    DeclarationContext,
};

use super::{HirNode, HirNodeValue};

pub fn rewrite(declarations: &DeclarationContext, root: &mut HirNode) {
    // We only care about function calls that are an access on the left hand side
    let HirNodeValue::Call(call_lhs, args) = &mut root.value else {
        return;
    };
    let HirNodeValue::Access(lhs, func_name) = &mut call_lhs.value else {
        return;
    };
    match fully_dereference(&lhs.ty) {
        ExpressionType::InstanceOf(ty_id) | ExpressionType::ReferenceToType(ty_id) => {
            match declarations.id_to_decl.get(ty_id) {
                Some(TypeDeclaration::Struct(StructType {
                    associated_functions,
                    ..
                })) => {
                    if let Some(func_id) = associated_functions.get(func_name) {
                        // Replace the existing left hand side with a reference to the called function
                        let mut temporary = HirNode::autogenerated(
                            HirNodeValue::VariableReference((*func_id).into()),
                            ExpressionType::ReferenceToFunction(*func_id),
                        );
                        std::mem::swap(&mut temporary, call_lhs);
                        // Insert the struct as a parameter to the newly called function
                        let call_lhs = temporary;
                        let HirNodeValue::Access(lhs, _) = call_lhs.value else {
                            unreachable!();
                        };
                        args.insert(0, *lhs);
                    }
                }
                Some(TypeDeclaration::Interface(InterfaceType {
                    associated_functions,
                    ..
                })) => {
                    if let Some(fn_id) = associated_functions.get(func_name) {
                        // TODO: restore this?
                        // Insert the interface as a parameter to itself
                        args.insert(
                            0,
                            HirNode::autogenerated(
                                HirNodeValue::InterfaceAddress(lhs.clone()),
                                ExpressionType::Primitive(PrimitiveType::PointerSize),
                            ),
                        );

                        let mut temp = HirNode::dummy();
                        std::mem::swap(&mut temp, root);
                        let HirNode {
                            id,
                            value: HirNodeValue::Call(lhs, args),
                            ty,
                            provenance: _,
                        } = temp
                        else {
                            unreachable!()
                        };
                        let HirNodeValue::Access(lhs, _func_name) = lhs.value else {
                            unreachable!()
                        };
                        temp = HirNode::generated_with_id(
                            id,
                            HirNodeValue::VtableCall(lhs, *fn_id, args),
                            ty,
                        );
                        std::mem::swap(&mut temp, root);
                    }
                }
                _ => {}
            }
        }
        ty @ ExpressionType::Collection(col_ty) => {
            let ty = ty.clone();

            let runtime_fns = match col_ty {
                CollectionType::Array(_) => &declarations.array_intrinsics,
                CollectionType::Dict(_, _) => &declarations.dict_intrinsics,
                CollectionType::String => todo!(),
            };

            let runtime_fn = &runtime_fns[func_name.as_str()];

            let mut temp_lhs = HirNode::dummy();
            std::mem::swap(lhs as &mut HirNode, &mut temp_lhs);

            temp_lhs = HirNode::autogenerated(
                if runtime_fn.ptr_ty == PointerKind::Shared {
                    HirNodeValue::TakeShared(Box::new(temp_lhs))
                } else {
                    HirNodeValue::TakeUnique(Box::new(temp_lhs))
                },
                ExpressionType::Pointer(PointerKind::Shared, Box::new(ty)),
            );

            let mut runtime_args = Vec::new();
            std::mem::swap(args, &mut runtime_args);
            runtime_args.insert(0, temp_lhs);

            let fn_ty = &declarations.id_to_func[&runtime_fn.fn_id];
            std::mem::swap(
                root,
                &mut HirNode::generated_with_id(
                    root.id,
                    HirNodeValue::IntrinsicCall(runtime_fn.intrinsic_fn, runtime_args),
                    fn_ty.returns.clone(),
                ),
            );
        }
        ExpressionType::Generator { .. } => {}
        ty => unreachable!(
            "illegal lhs of access in function call: {:?} in {:?}",
            ty, lhs
        ),
    }
}
