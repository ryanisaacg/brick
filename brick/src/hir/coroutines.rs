use crate::{
    id::{AnyID, VariableID},
    typecheck::{fully_dereference, ExpressionType, PointerKind},
};

use super::{GeneratorProperties, HirModule, HirNode, HirNodeValue};

pub fn rewrite_generator_calls(module: &mut HirModule) {
    module.visit_mut(|node| {
        let HirNodeValue::Call(func, args) = &mut node.value else {
            return;
        };
        let ExpressionType::Generator { yield_ty, param_ty } = fully_dereference(&func.ty) else {
            return;
        };

        let mut parameters = vec![ExpressionType::Pointer(
            PointerKind::Unique,
            Box::new(ExpressionType::Generator {
                yield_ty: yield_ty.clone(),
                param_ty: param_ty.clone(),
            }),
        )];
        if param_ty.as_ref() != &ExpressionType::Void {
            parameters.push(param_ty.as_ref().clone());
        }

        let yield_ty = yield_ty.clone();

        let mut generator = HirNode::dummy();
        std::mem::swap(func.as_mut(), &mut generator);
        let gen_ty = generator.ty.clone();

        let function_id = HirNode::autogenerated(
            HirNodeValue::Access(Box::new(generator.clone()), "function".to_string()),
            ExpressionType::FunctionReference {
                parameters,
                returns: yield_ty,
            },
        );

        if !matches!(
            &generator.ty,
            ExpressionType::Pointer(PointerKind::Unique, _)
        ) {
            generator = HirNode::autogenerated(
                HirNodeValue::TakeUnique(Box::new(generator)),
                ExpressionType::Pointer(PointerKind::Unique, Box::new(gen_ty)),
            );
        }

        args.insert(0, generator);

        **func = function_id;
    });
}

pub fn rewrite_yields(module: &mut HirModule) {
    let mut jump_index = 1;

    for func in module.functions.iter_mut() {
        let Some(GeneratorProperties {
            generator_var_id,
            param_var_id,
            ty: gen_ty,
        }) = &func.generator
        else {
            continue;
        };
        let generator_var_id: AnyID = (*generator_var_id).into();
        find_yield_to_rewrite(
            gen_ty,
            generator_var_id,
            &mut func.body,
            &mut Vec::new(),
            &mut jump_index,
            *param_var_id,
        );
    }
}

/**
 * Hoist all yield expressions out of other statements, and correctly leave variable references in
 * their place
 */
fn find_yield_to_rewrite(
    gen_ty: &ExpressionType,
    generator_var_id: AnyID,
    node: &mut HirNode,
    yield_queue: &mut Vec<YieldInfo>,
    jump_index: &mut usize,
    param_var_id: Option<VariableID>,
) {
    match &mut node.value {
        HirNodeValue::Sequence(children) => {
            let mut idx = 0;
            let mut yield_queue = Vec::new();
            while idx < children.len() {
                find_yield_to_rewrite(
                    gen_ty,
                    generator_var_id,
                    &mut children[idx],
                    &mut yield_queue,
                    jump_index,
                    param_var_id,
                );
                let ExpressionType::Pointer(_, inner_gen_ty) = &gen_ty else {
                    unreachable!();
                };
                let ExpressionType::Generator { param_ty, .. } = inner_gen_ty.as_ref() else {
                    unreachable!();
                };
                for yield_info in yield_queue.drain(..) {
                    if let Some(temp_var_id) = yield_info.temp_var_id {
                        children.insert(
                            idx,
                            HirNode::autogenerated(
                                HirNodeValue::Declaration(temp_var_id),
                                param_ty.as_ref().clone(),
                            ),
                        );
                        idx += 1;
                        children.insert(
                            idx,
                            HirNode::autogenerated(
                                HirNodeValue::Assignment(
                                    Box::new(HirNode::autogenerated(
                                        HirNodeValue::VariableReference(temp_var_id.into()),
                                        param_ty.as_ref().clone(),
                                    )),
                                    Box::new(HirNode::autogenerated(
                                        HirNodeValue::VariableReference(
                                            param_var_id.unwrap().into(),
                                        ),
                                        param_ty.as_ref().clone(),
                                    )),
                                ),
                                ExpressionType::Void,
                            ),
                        );
                        idx += 1;
                    }
                    for node in expanded_yield(
                        generator_var_id,
                        yield_info.jump_index,
                        gen_ty,
                        yield_info.returned_value,
                    ) {
                        children.insert(idx, node);
                        idx += 1;
                    }
                }
                idx += 1;
            }
        }
        HirNodeValue::Yield(yielded) => {
            if param_var_id.is_some() {
                let temp_var_id = VariableID::new();
                let yield_info = YieldInfo {
                    returned_value: std::mem::take(yielded),
                    jump_index: *jump_index,
                    temp_var_id: Some(temp_var_id),
                };
                yield_queue.push(yield_info);
                node.value = HirNodeValue::VariableReference(temp_var_id.into());
            } else {
                node.value = HirNodeValue::Sequence(expanded_yield(
                    generator_var_id,
                    *jump_index,
                    gen_ty,
                    std::mem::take(yielded),
                ));
            }
            *jump_index += 1;
        }
        _ => {
            node.children_mut(|child| {
                find_yield_to_rewrite(
                    gen_ty,
                    generator_var_id,
                    child,
                    yield_queue,
                    jump_index,
                    param_var_id,
                );
            });
        }
    }
}

fn expanded_yield(
    generator_var_id: AnyID,
    jump_index: usize,
    gen_ty: &ExpressionType,
    returned_value: Option<Box<HirNode>>,
) -> Vec<HirNode> {
    // TODO: write to variable ID
    vec![
        HirNode::autogenerated(
            HirNodeValue::GeneratorSuspend(
                Box::new(HirNode::autogenerated(
                    HirNodeValue::VariableReference(generator_var_id),
                    gen_ty.clone(),
                )),
                jump_index,
            ),
            ExpressionType::Void,
        ),
        HirNode::autogenerated(HirNodeValue::Return(returned_value), ExpressionType::Void),
        HirNode::autogenerated(HirNodeValue::GotoLabel(jump_index), ExpressionType::Void),
    ]
}

struct YieldInfo {
    returned_value: Option<Box<HirNode>>,
    jump_index: usize,
    temp_var_id: Option<VariableID>,
}
