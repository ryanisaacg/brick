use crate::{
    id::{NodeID, VariableID},
    DeclarationContext, ExpressionType, HirNodeValue,
};

use super::{HirModule, HirNode};

pub fn discard_unused_values(module: &mut HirModule, declarations: &DeclarationContext) {
    module.par_visit_mut(|node| {
        let does_return_value =
            node.ty != ExpressionType::Void && node.ty != ExpressionType::Unreachable;
        let HirNodeValue::Sequence(children) = &mut node.value else {
            return;
        };
        for idx in 0..children.len() {
            if does_return_value && idx == children.len() - 1 {
                continue;
            }
            let child = &mut children[idx];
            if child.ty == ExpressionType::Void
                || child.ty == ExpressionType::Unreachable
                || matches!(
                    &child.value,
                    HirNodeValue::Declaration(..) | HirNodeValue::Parameter(..)
                )
            {
                continue;
            }
            let child_value = std::mem::take(child);
            let provenance = child_value.provenance.clone();
            // Affine types need to be dropped, so assign it to a temporary variable instead of
            // discarding
            if child_value.ty.is_affine(&declarations.id_to_decl) {
                let temp_var_id = VariableID::new();
                *child = HirNode::autogenerated(
                    HirNodeValue::Sequence(vec![
                        HirNode {
                            id: NodeID::new(),
                            value: HirNodeValue::Declaration(temp_var_id),
                            ty: child_value.ty.clone(),
                            provenance: provenance.clone(),
                        },
                        HirNode {
                            id: NodeID::new(),
                            value: HirNodeValue::Assignment(
                                Box::new(HirNode::autogenerated(
                                    HirNodeValue::VariableReference(temp_var_id.into()),
                                    child_value.ty.clone(),
                                )),
                                Box::new(child_value),
                            ),
                            ty: ExpressionType::Void,
                            provenance,
                        },
                    ]),
                    ExpressionType::Void,
                );
            } else {
                *child = HirNode {
                    id: NodeID::new(),
                    value: HirNodeValue::Discard(Box::new(child_value)),
                    ty: ExpressionType::Void,
                    provenance,
                };
            }
        }
    });
}
