use std::collections::HashMap;

use crate::{
    declaration_context::IntrinsicFunction,
    hir::{HirFunction, HirModule, HirNode},
    id::VariableID,
    typecheck::{CollectionType, PointerKind, PrimitiveType, StructType},
    DeclarationContext, ExpressionType, FuncType, HirNodeValue, TypeDeclaration,
};

pub fn generate_destructors(modules: &mut Vec<HirModule>, declarations: &mut DeclarationContext) {
    let mut need_generated_destructor = Vec::new();
    let mut destructor_exists = Vec::new();

    for (decl_id, decl) in declarations
        .id_to_decl
        .iter()
        .filter(|(_, decl)| decl.is_affine())
    {
        match decl {
            TypeDeclaration::Struct(StructType {
                associated_functions,
                ..
            }) => {
                if associated_functions.contains_key("drop") {
                    destructor_exists.push(*decl_id);
                } else {
                    need_generated_destructor.push(*decl_id);
                }
            }
            TypeDeclaration::Union(_) => {
                // In the future unions will have custom destructors
                need_generated_destructor.push(*decl_id);
            }
            TypeDeclaration::Interface(_) | TypeDeclaration::Module(_) => unreachable!(),
        }
    }

    let mut gen_destructor_module = HirModule {
        top_level_statements: HirNode::new_void(HirNodeValue::Sequence(Vec::new())),
        functions: Vec::new(),
    };

    for decl_id in need_generated_destructor.iter() {
        let decl = declarations.id_to_decl.get_mut(decl_id).unwrap();
        let destructor_id = declarations.auto_destructors_module.new_func_id();
        declarations.id_to_func.insert(
            destructor_id,
            FuncType {
                id: destructor_id,
                type_param_count: 0,
                params: vec![ExpressionType::Pointer(
                    PointerKind::Unique,
                    Box::new(ExpressionType::InstanceOf(*decl_id)),
                )],
                returns: ExpressionType::Void,
                is_associated: true,
                is_coroutine: false,
                provenance: None,
            },
        );

        match decl {
            TypeDeclaration::Struct(StructType {
                associated_functions,
                ..
            }) => {
                associated_functions.insert("drop".to_string(), destructor_id);
            }
            TypeDeclaration::Union(_) => todo!(),
            TypeDeclaration::Interface(_) | TypeDeclaration::Module(_) => unreachable!(),
        }
    }

    for decl_id in need_generated_destructor {
        let param = VariableID::new();
        let mut destructor_body = vec![HirNode::autogenerated(
            HirNodeValue::Parameter(0, param),
            ExpressionType::Pointer(
                PointerKind::Unique,
                Box::new(ExpressionType::InstanceOf(decl_id)),
            ),
        )];
        let destructor_id;

        match &declarations.id_to_decl[&decl_id] {
            TypeDeclaration::Struct(
                ty @ StructType {
                    associated_functions,
                    ..
                },
            ) => {
                destructor_id = associated_functions["drop"];
                drop_struct_children(declarations, ty, param, &mut destructor_body);
            }
            TypeDeclaration::Union(_) => todo!(),
            TypeDeclaration::Interface(_) | TypeDeclaration::Module(_) => unreachable!(),
        };

        gen_destructor_module.functions.push(HirFunction {
            id: destructor_id,
            name: None,
            body: HirNode::new_void(HirNodeValue::Sequence(destructor_body)),
            generator: None,
        });
    }

    let mut func_id_to_func_def = HashMap::new();
    for module in modules.iter_mut() {
        for func in module.functions.iter_mut() {
            func_id_to_func_def.insert(func.id, func);
        }
    }

    for decl_id in destructor_exists {
        match &declarations.id_to_decl[&decl_id] {
            TypeDeclaration::Struct(
                ty @ StructType {
                    associated_functions,
                    ..
                },
            ) => {
                let func_id = associated_functions["drop"];
                let func = func_id_to_func_def.get_mut(&func_id).unwrap();
                let HirNodeValue::Sequence(destructor_body) = &mut func.body.value else {
                    unreachable!()
                };
                let HirNodeValue::Parameter(_, param) = &destructor_body[0].value else {
                    unreachable!()
                };
                let param = *param;
                drop_struct_children(declarations, ty, param, destructor_body);
            }
            TypeDeclaration::Union(_) => todo!(),
            TypeDeclaration::Interface(_) | TypeDeclaration::Module(_) => unreachable!(),
        };
    }

    modules.push(gen_destructor_module);
}

fn drop_struct_children(
    decls: &DeclarationContext,
    ty: &StructType,
    var_id: VariableID,
    body: &mut Vec<HirNode>,
) {
    for (name, field_ty) in ty.fields.iter() {
        if field_ty.is_affine(&decls.id_to_decl) {
            drop_variable(
                decls,
                body,
                HirNode::autogenerated(
                    HirNodeValue::TakeUnique(Box::new(HirNode::autogenerated(
                        HirNodeValue::Access(
                            Box::new(HirNode::autogenerated(
                                HirNodeValue::Dereference(Box::new(HirNode::autogenerated(
                                    HirNodeValue::VariableReference(var_id.into()),
                                    ExpressionType::Pointer(
                                        PointerKind::Unique,
                                        Box::new(ExpressionType::InstanceOf(ty.id)),
                                    ),
                                ))),
                                ExpressionType::InstanceOf(ty.id),
                            )),
                            name.to_string(),
                        ),
                        field_ty.clone(),
                    ))),
                    ExpressionType::Pointer(PointerKind::Unique, Box::new(field_ty.clone())),
                ),
                field_ty,
            );
        }
    }
}

pub fn drop_variable(
    decls: &DeclarationContext,
    children: &mut Vec<HirNode>,
    value: HirNode,
    ty: &ExpressionType,
) {
    match ty {
        ExpressionType::Void
        | ExpressionType::Unreachable
        | ExpressionType::Primitive(_)
        | ExpressionType::ReferenceToFunction(_)
        | ExpressionType::ReferenceToType(_)
        | ExpressionType::Pointer(_, _)
        | ExpressionType::Null
        | ExpressionType::FunctionReference { .. } => {}
        ExpressionType::Collection(CollectionType::Array(_)) => {
            children.push(HirNode::new_void(HirNodeValue::IntrinsicCall(
                IntrinsicFunction::ArrayFree,
                vec![value],
            )));
        }
        ExpressionType::Collection(CollectionType::Dict(_, _)) => {
            // TODO
        }
        ExpressionType::Collection(CollectionType::String) => {
            // TODO
        }
        ExpressionType::Collection(CollectionType::Cell(inner)) => {
            drop_variable(decls, children, value, inner.as_ref());
        }
        ExpressionType::Collection(CollectionType::ReferenceCounter(inner_ty)) => {
            let value =
                HirNode::autogenerated(HirNodeValue::Dereference(Box::new(value)), ty.clone());
            let mut drop_body = Vec::new();
            drop_variable(
                decls,
                &mut drop_body,
                HirNode::autogenerated(
                    HirNodeValue::TakeUnique(Box::new(HirNode::autogenerated(
                        HirNodeValue::Dereference(Box::new(value.clone())),
                        inner_ty.as_ref().clone(),
                    ))),
                    ExpressionType::Pointer(PointerKind::Unique, inner_ty.clone()),
                ),
                inner_ty.as_ref(),
            );
            drop_body.push(HirNode::new_void(HirNodeValue::IntrinsicCall(
                IntrinsicFunction::RcFree,
                vec![value.clone()],
            )));
            children.push(HirNode::new_void(HirNodeValue::If(
                Box::new(HirNode::autogenerated(
                    HirNodeValue::IntrinsicCall(IntrinsicFunction::RcDecrement, vec![value]),
                    ExpressionType::Primitive(PrimitiveType::Bool),
                )),
                Box::new(HirNode::new_void(HirNodeValue::Sequence(drop_body))),
                None,
            )));
        }
        ExpressionType::Generator { .. } => {
            // TODO
        }
        ExpressionType::InstanceOf(ty_id) => {
            // TODO: drop unions
            // TODO: should interfaces drop? I think no?
            if let TypeDeclaration::Struct(StructType {
                associated_functions,
                ..
            }) = &decls.id_to_decl[ty_id]
            {
                if let Some(drop_fn_id) = associated_functions.get("drop") {
                    children.push(HirNode::new_void(HirNodeValue::Call(
                        Box::new(HirNode::autogenerated(
                            HirNodeValue::VariableReference((*drop_fn_id).into()),
                            ExpressionType::ReferenceToFunction(*drop_fn_id),
                        )),
                        vec![value],
                    )));
                }
            }
        }
        ExpressionType::Nullable(_) => {
            // TODO
        }
        ExpressionType::TypeParameterReference(_) => todo!(),
    }
}
