use std::collections::HashMap;

use crate::{
    id::TypeID,
    typecheck::{ExpressionType, StaticDeclaration},
};

use super::{HirModule, HirNode, HirNodeValue};

pub fn rewrite(module: &mut HirModule, declarations: &HashMap<TypeID, &StaticDeclaration>) {
    module.visit_mut(|node| {
        node.walk_expected_types_for_children_mut(declarations, |expected_ty, child| {
            let ExpressionType::InstanceOf(expected_ty_id) = expected_ty else {
                return;
            };
            let Some(StaticDeclaration::Interface(expected_ty)) = declarations.get(expected_ty_id)
            else {
                return;
            };

            let ExpressionType::InstanceOf(child_ty_id) = &child.ty else {
                return;
            };
            let Some(StaticDeclaration::Struct(child_ty)) = declarations.get(child_ty_id) else {
                return;
            };

            let mut vtable = HashMap::new();
            for (name, func) in expected_ty.associated_functions.iter() {
                vtable.insert(
                    func.unwrap_fn_id(),
                    child_ty
                        .associated_functions
                        .get(name)
                        .expect("associated function to exist")
                        .unwrap_fn_id(),
                );
            }
            let ty = ExpressionType::InstanceOf(expected_ty.id);

            let mut temp = HirNode::dummy();
            std::mem::swap(&mut temp, child);

            *child = HirNode::autogenerated(
                HirNodeValue::StructToInterface {
                    value: Box::new(temp),
                    vtable,
                },
                ty,
            );
        });
    });
}
