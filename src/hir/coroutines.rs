use std::collections::HashMap;

use crate::{
    id::TypeID,
    typecheck::{ExpressionType, PointerKind, PrimitiveType, StaticDeclaration},
};

use super::{ComparisonOp, HirModule, HirNode, HirNodeValue};

pub fn take_coroutine_references(module: &mut HirModule) {
    module.visit_mut(|node| {
        let HirNodeValue::CallGenerator(gen, _) = &mut node.value else {
            return;
        };
        if !matches!(&gen.ty, &ExpressionType::Generator { .. }) {
            return;
        }

        let ty = gen.ty.clone();

        let mut temp = HirNode::dummy();
        std::mem::swap(gen.as_mut(), &mut temp);

        temp = HirNode::autogenerated(
            HirNodeValue::TakeUnique(Box::new(temp)),
            ExpressionType::Pointer(PointerKind::Unique, Box::new(ty)),
        );

        std::mem::swap(gen.as_mut(), &mut temp);
    });
}

pub fn coroutine_calls(module: &mut HirModule, decls: &HashMap<TypeID, &StaticDeclaration>) {
    module.visit_mut(|node| {
        let HirNodeValue::Call(lhs, params) = &mut node.value else {
            return;
        };
        let ExpressionType::ReferenceTo(fn_id) = &lhs.ty else {
            return;
        };
        let Some(StaticDeclaration::Func(fn_ty)) = decls.get(fn_id) else {
            return;
        };
        if fn_ty.is_coroutine {
            let lhs = std::mem::replace(lhs, Box::new(HirNode::dummy()));
            let params = std::mem::take(params);
            node.value = HirNodeValue::CoroutineStart(lhs, params);
        }
    });
}

pub fn add_resumes(module: &mut HirModule) {
    // TODO: top-level statements?
    // add_resumes_to_fn(&mut module.top_level_statements);
    for fun in module.functions.iter_mut() {
        if fun.is_generator {
            add_resumes_to_fn(&mut fun.body);
        }
    }
}

fn add_resumes_to_fn(body: &mut HirNode) {
    let mut yield_idx = 1;
    body.visit_mut(|child| {
        let HirNodeValue::Yield(idx, _) = &mut child.value else {
            return;
        };
        *idx = yield_idx;
        yield_idx += 1;
    });

    add_resumes_to_node(body, &mut 1);
}

// TODO: optimize data structure usage - constant push / pull from front isn't ideal
fn add_resumes_to_node(node: &mut HirNode, resume_index: &mut usize) {
    let HirNodeValue::Sequence(children) = &mut node.value else {
        return;
    };
    let mut yield_accumulator = Vec::new();
    let mut child_index = 0;

    while child_index < children.len() {
        yield_accumulator.push(children.remove(child_index));
        if let HirNodeValue::Yield(yield_idx, _) = &yield_accumulator.last().unwrap().value {
            let yield_idx = *yield_idx;

            let cond = HirNode::autogenerated(
                HirNodeValue::Comparison(
                    ComparisonOp::LessThan,
                    Box::new(HirNode::autogenerated(
                        HirNodeValue::ResumePoint,
                        ExpressionType::Primitive(PrimitiveType::PointerSize),
                    )),
                    Box::new(HirNode::autogenerated(
                        HirNodeValue::PointerSize(*resume_index),
                        ExpressionType::Primitive(PrimitiveType::PointerSize),
                    )),
                ),
                ExpressionType::Primitive(PrimitiveType::Bool),
            );
            let body = HirNode::autogenerated(
                HirNodeValue::Sequence(std::mem::take(&mut yield_accumulator)),
                ExpressionType::Void,
            );
            children.insert(
                child_index,
                HirNode::autogenerated(
                    HirNodeValue::If(Box::new(cond), Box::new(body), None),
                    ExpressionType::Void,
                ),
            );
            child_index += 1;

            *resume_index = yield_idx;
        }
    }

    children.append(&mut yield_accumulator);
}
