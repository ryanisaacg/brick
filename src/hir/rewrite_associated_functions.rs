use std::collections::HashMap;

use crate::{
    id::TypeID,
    typecheck::{ExpressionType, InterfaceType, PrimitiveType, StaticDeclaration, StructType},
};

use super::{HirNode, HirNodeValue};

pub fn rewrite(declarations: &HashMap<TypeID, &StaticDeclaration>, root: &mut HirNode) {
    // We only care about function calls that are an access on the left hand side
    let HirNodeValue::Call(call_lhs, args) = &mut root.value else {
        return;
    };
    let HirNodeValue::Access(lhs, func_name) = &mut call_lhs.value else {
        return;
    };
    let ExpressionType::DeclaredType(ty_id) = &lhs.ty else {
        panic!("lhs of access must be a user-declared type");
    };
    match declarations.get(ty_id) {
        Some(StaticDeclaration::Struct(StructType {
            associated_functions,
            ..
        })) => {
            if let Some(func) = associated_functions.get(func_name) {
                // Replace the existing left hand side with a reference to the called function
                let mut temporary = HirNode::autogenerated(
                    HirNodeValue::VariableReference(func.unwrap_fn_id().into()),
                    func.expr(),
                );
                std::mem::swap(&mut temporary, call_lhs);
                // Insert the struct as a parameter to the newly called function
                let call_lhs = temporary;
                let HirNodeValue::Access(lhs, _) = call_lhs.value else {
                    unreachable!();
                };
                args.insert(0, *lhs);
            }
        }
        Some(StaticDeclaration::Interface(InterfaceType {
            associated_functions,
            ..
        })) => {
            if let Some(func) = associated_functions.get(func_name) {
                // TODO: restore this?
                // Insert the interface as a parameter to itself
                args.insert(
                    0,
                    HirNode::autogenerated(
                        HirNodeValue::InterfaceAddress(lhs.clone()),
                        ExpressionType::Primitive(PrimitiveType::PointerSize),
                    ),
                );

                let mut temp = HirNode::dummy();
                std::mem::swap(&mut temp, root);
                let HirNode {
                    id,
                    value: HirNodeValue::Call(lhs, args),
                    ty,
                    provenance: _,
                } = temp
                else {
                    unreachable!()
                };
                let HirNodeValue::Access(lhs, _func_name) = lhs.value else {
                    unreachable!()
                };
                temp = HirNode::generated_with_id(
                    id,
                    HirNodeValue::VtableCall(lhs, func.unwrap_fn_id(), args),
                    ty,
                );
                std::mem::swap(&mut temp, root);
            }
        }
        _ => {}
    }
}
